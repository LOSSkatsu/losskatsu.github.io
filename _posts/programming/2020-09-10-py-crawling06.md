---
title: "[python] 파이썬 웹 크롤링(6): 데이터 읽기" 
categories:
  - programming
tags:
  - programming
use_math: true
toc: true
toc_label: "My Table of Contents"
toc_icon: "cog"
sidebar:
  title: "AI Machine Learning"
  nav: sidebar-contents
---

# 파이썬 웹 크롤링(6): 데이터 읽기 

본 포스팅은 Web Scraping with Python by Ryan Mitchell을 참고하였습니다. 

**참고 링크**

* [파이썬 웹 크롤링(1): 크롤링의 기본구조와 BeautifulSoup 설치](https://losskatsu.github.io/programming/py-crawling01/)
* [파이썬 웹 크롤링(2): 데이터 파싱하기](https://losskatsu.github.io/programming/py-crawling02/)
* [파이썬 웹 크롤링(3): 본격적인 크롤링](https://losskatsu.github.io/programming/py-crawling03/)
* [파이썬 웹 크롤링(4): API 활용하기](https://losskatsu.github.io/programming/py-crawling04/) 
* [파이썬 웹 크롤링(5): 데이터 저장하기](https://losskatsu.github.io/programming/py-crawling05/) 


# Chapter 6: 데이터 읽기
 
## 6.1 데이터 인코딩

데이터 인코딩이 의미하는 것은 여러분의 컴퓨터 운영체제 혹은 파이썬 코드가 자료를 어떻게 읽을지를 결정하는 것을 의미합니다. 
인코딩은 파일 확장자를 보고 추론할 수 있습니다. 물론 파일 확장자만 보고 절대적으로 판단할수는 없지만 예를 들어
myImage.jpg 파일을 myImage.txt로 저장하는 것은 문제가 없습니다. 
적어도 텍스트 에디터가 해당 파일을 열기 전까지는요. 
이런 경우는 드문 케이스 이지만 파일 확장자만 알면 데이터를 읽는데는 문제 없습니다. 

좀 더 근본적인 레벨로 내려가면 모든 자료는 0 또는 1로 인코딩 되어 있습니다. 
뿐만 아니라, 문자당 몇 비트를 쓸 것인지 혹은 각 픽셀 마다 색깔을 표현하는데 몇비트를 결정하는 인코딩 알고리즘이 존재합니다. 
또한 PNG 파일과 같이 압축관련된 알고리즘도 있습니다. 
비록 HTML 파일이 아닌 경우에는 겁이 날 수 있지만 우리에게는 파이썬 라이브러리가 있습니다. 
파이썬은 어떤 종류의 포맷이라도 처리할 수있도록 라이브러리가 잘 갖춰져 있습니다. 
텍스트파일, 비디오 파일, 이미지파일과 같은 서로다른 포맷의 파일들의 유일한 차이는 
0과 1을 어떻게 해석하느냐 입니다. 이번 챕터에서는 text, pdf, png, gif 파일에 대해 알아보겠습니다.

## 6.2 Text

텍스트 파일을 평문 그대로 저장하는 것은 흔하지는 않지만 오래된 사이트에서는 이렇게 저장하는 경우도 있습니다. 
대부분의 웹 브라우저에서는 텍스트 파일을 크롤링하는데 문제 없습니다. 

```python
from urllib.request import urlopen
textPage = urlopen(
        "http://www.pythonscraping.com/pages/warandpeace/chapter1.txt")
print(textPage.read())
```

보통, urlopen을 통해 페이지를 검색할때, HTML을 파싱하기 위해 BeautifulSoup 오브젝트로 변환 시키는데. 
이 경우, 우리는 페이지를 다이렉트로 읽습니다. 
파싱할 HTML 파일이 없다면 라이브러리는 쓸모가 없습니다. 
텍스트 파일을 string으로 읽는다면 여러분은 이를 파이썬으로 읽기위해 또다른 분석이 필요할 것입니다. 
이것이 단점인데, 여러분은 HTML 태그를 문맥상 단서로 사용할 수 없습니다. 
이는 여러분이 원하는것과 원하지 않는 것을 집어내기 어렵다는 뜻입니다. 결국 텍스트 파일 내부에서 여러분이 원하는 정보를 얻기 어렵다는 뜻입니다. 

### 6.2.1 텍스트 인코딩에 관하여 

앞서 파일 확장자만 알면 파일을 읽는데 문제가 없다고 했습니다. 하지만 그게 모두에게 해당하는 말은 아닙니다. 
예를 들어 txt 파일이라고 하죠. 
10번 중 9번은 텍스트 파일을 읽는데 문제가 없습니다. 
하지만 인터넷에 있는 텍스트를 읽는건 꽤 까다로울 수 있습니다. 
이번 장에서는 영어를 비롯한 각종 언어들을 인코딩하는 기본 방법인 ASCII 부터 유니코드, ISO까지 한번 알아봅시다.

1990년대 초반, 유니코드 콘소시움은 어떤 언어이던지,
어떤 텍스트 문서이던지에 상관없이 모든 문자를 인코딩할 수 있는 전세계적인 텍스트 인코더를 만드는 것을 시도합니다. 
목표는 라틴 알파벳부터 중국 한문, 수학기호, 특수기호를 포함합니다. 
결과적으로 만들어진 인코더는 UTF-8 입니다. 
UTF-8은 Universal Character Set - Transformation Format 8 bit을 의미합니다. 
UTF-8에 대한 흔한 오해는 모든 문자를 8비트로 저장한다고 생각하는 것입니다. 
하지만 8비트는 문자를 저장하고 보여주기 위한 가장 작은 사이즈이지 최대 사이즈가 아닙니다. 
만약 UTF-8이 모든 문자를 8비트에 저장한다면 표현 가능한 문자는 오직 2의 8승 개 입니다. 
이는 고작 256개 밖에 되지 않습니다. 

현실적으로, UTF-8의 각 문자는 이렇게 시작했습니다. 
오직 1 바이트가 이 문자를 인코딩 하는데 사용된다, 혹은, 
그 다음 2 바이트는 single character를 인코딩합니다. 
최대 4바이트가 사용됩니다. 
왜냐하면 이러한 4바이트는 해당 문자를 인코딩하는데 얼마나 많은 바이트가 필요한지에 대한 정보를 포함합니다. 
full 32비트가 사용되지는 않고 정보의 21비트가 사용될 수 있습니다. 
이는 전체 2,097,152개의 가능한 문자에 해당하는 것입니다. 
현재 사용중인 문자는 1,113,112개 입니다. 

비록 유니코드 다양한 분야에 사용되지만 ASCII 또한 여전히 많은 사람들이 사용중입니다. 
ASCII(이하 아스키)는 1960년대 이래로 쭉 사용중인 텍스트 인코딩 방법입니다. 
아스키는 문자하나를 인코딩하는데 오직 7비트를 사용합니다. 따라서 총 사용가능한 문자는 2의 7승개, 128개의 문자입니다. 
이것은 라틴 알파벳(대, 소문자), 마침표, 또는 필수적인 문자를 포함합니다. 
물론 1960년대에는 문자를 7비트로 저장하느냐와 8비트로 저장하느냐는 엄청난 차이가 있었습니다. 
왜냐하면 그 당시에는 저장 장치가 매우 비쌌기 때문입니다. 
컴퓨터 사이언스는 저장하는데 비트를 더 써서 개발하기가 편하지느냐, 
아니면 용량을 아껴 쓰서 효율적으로 개발하느냐와 싸워왔습니다. 
결국 7비트가 승리했습니다. 
하지만 현대에는 7비트의 시퀀스는 초반에 0으로 패딩되어있습니다. 

