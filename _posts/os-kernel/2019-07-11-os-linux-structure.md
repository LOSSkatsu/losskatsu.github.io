---
title: "[운영체제] 리눅스 구조 정리" 
categories:
  - os-kernel
tags:
  - os
use_math: true
toc: true
toc_label: "My Table of Contents"
toc_icon: "cog"
sidebar:
  title: "AI Machine Learning"
  nav: sidebar-contents
---

# [운영체제] 리눅스 구조 정리

## 1. 컴퓨터 시스템 개요

컴퓨터의 기본 요소는 CPU와 메모리. CPU는 메모리에 있는 내용을 읽고 연산 결과를 메모리의 다른 영역에 기록한다. 

프로그램: 사용자에게 필요한 하나의 처리(기능)로 정리한 것

일반적으로 OS는 여러가지 프로그램을 프로세스 단위로 실행. OS는 여러개의 프로세스를 동시에 실행 가능. 

애플리케이션: 사용자가 직접 사용 


## 2. 사용자 모드로 구현되는 기능

프로세스는 커널의 도움이 필요할 경우 시스템 콜을 통해 커널에 처리를 요청.

시스템 콜의 종류

* 프로세스 생성, 삭제
* 메모리 확보, 해제
* 프로세스 간 통산(IPC)
* 네트워크
* 파일 시스템 다루기
* 파일 다루기(디바이스 접근)

프로세스는 보통 사용자 모드로 실행되고 있지만 커널에 처리를 요청하고자 시스템 콜을 호출하면 CPU에서는 인터럽트 이벤트 발생. 
인터럽트 이벤트가 발생하면 CPU는 사용자 모드에서 커널 모드로 변경되며 요청한 내용을 처리하기 위해 커널은 동작하기 시작함. 

strace: 프로세스가 어떤 시스템 콜을 호출했는지 확인 가능.

```bash
$ strace -o hello.log ./hello
```

sar: 프로세스가 사용자 모드와 커널 모드 중 어느쪽에서 실행되고 있는지 비율 확인

```bash
$ sar -P ALL 1 1
```
이 때, 세번째 파라미터는 1초 단위로 측정(측정 시간 단위), 네번째 파라미터는 1회 측정(측정 횟수). 
%user + %nice = 사용자모드, %system = 커널모드. 
대체로 %system 수치가 크면 시스템에 과부하가 걸려있는 등 좋지 않은 상태를 뜻함. 
<br />

시스템 콜은 C언어 같은 고급언어에서는 호출이 불가능하다. 아케텍처에 의존하는 어셈블리 코드를 사용해 호출해야함. 
이러한 문제를 해결하기 위해 OS는 내부적으로 시스템 콜을 호출하는 일만 하는 함수를 제공하는 데, 이를 wrapper라고 한다. 

ldd: 프로그램이 어떤 라이브러리를 링크하고 있는지 확인

```bash
$ ldd /bin/echo
```

## 3. 프로세스 관리

fork(): 실행한 프로세스와 함께 새로운 프로세스 1개 생성. 같은 프로그램의 처리를 여러 개의 나눠서 처리함. 

execve(): 전혀 다른 프로그램 생성 시 사용. 

엔트리포인트(entry point): 최초로 실행할 명령의 메모리 주소

리눅스의 실행파일은 ELF(Executable Linkable Format)이라는 형식 사용. 

readelf: ELF 형식의 각종 정보 확인 가능. -h옵션으로 시작 주소 획득 가능. 
-S 옵션으로 오프셋, 사이즈, 메모리맵 시작주소 확인 가능. 
결과에서 .text는 코드영역 정보, .data는 데이터 영역 정보를 의미  

```bash
$ readelf -h /bin/sleep
$ readelf -S /bin/sleep
```

## 4. 프로세스 스케줄러

프로세스 스케줄러(process scheduler)라는 기능은 여러개의 프로세스를 동시에 동작시킴. 
정확히는 동시에 동작시키는 것처럼 보이게한다. 

타임슬라이스: 하나의 CPU에 여러 개의 프로세스를 실행해야할 때 각 프로세스를 적절한 시간으로 쪼개서 번갈아 처리. 

컨텍스트 스위치(context switch): 논리 CPU 상에서 동작하는 프로세스가 바뀌는 것을 의미. 
프로세스가 어떤 프로그램을 수행 중이더라도 타임 슬라이스를 모두 소비하면 발생. 

하이퍼스레드(hyperthread) 기능이 있으면 각 코어 내의 각각의 하이퍼스레드가 논리 CPU로 인식됨. 

taskset: -c옵션으로 논리 CPU를 지정하고 여기에서만 지정한 프로그램을 동작하게 할 수 있음. 

```bash
$ taskset -c 0 ./sched <동시에 동작하는 프로세스 수> <프로그램 동작 총시간> <데이터 수집 간격>
$ taskset -c 0 ./sched 1 100 1
```

결과를 저장하고 싶다면

```bash
$ taskset -c 0 ./sched 1 100 1 > 1core-1process.txt 
```

스루풋(throughput): 단위 시간당 처리된 일의양 = 완료한 프로세스의 수 / 경과 시간

레이턴시(latency): 각각의 처리가 시작부터 종료까지의 경과된 시간 = 처리 종료 시간 - 처리 시작 시간 

로드밸런서: 여러 개의 논리 CPU에 프로세스를 공평하게 분배해 주는 역할을 함. 

ps -eo: time, etime 필드는 프로세스 시작 부터 현재까지의 경과 시간과 사용시간 표시 

```bash
$ ps -eo pid,comm,time,etime
```

## 5. 메모리 관리

free: 시스템의 총 메모리 양과 사용중인 메모리 양 확인

```bash
$ free
```

sar -r: 메모리에 관한 통계 정보 확인. 두번째 파라미터는 단위 초 간격 

```bash
$ sar -r 1
```

프로세스가 생성된 뒤 메모리의 획득, 해제를 반복하면 메모리 단편화(memory fragmentation) 문제 발생. 
이와 더불어 여러가지 문제를 해결하기 위해 가상 메모리 기능 탑재. 

가상 메모리: 시스템에 탑재된 메모리를 프로세스가 직접 접근하지 않고 가상 주소라는 주소를 사용하여 
간접적으로 접근하도록 하는 방식. 

가상 주소: 프로세스에 보이는 메모리 주소. readelf 쳤을 때 나온 주소는 가상 주소임. 

물리 주소: 시스템에 탑재된 메모리의 실제 주소

가상 주소 공간: 주소에 따라 접근 가능한 범위 

참고로 프로세스로 부터 메모리에 직접 접근하는 방법, 
즉, 물리 주소에 직접적으로 접근하는 방법은 없음. 


참고: 실습과 그림으로 배우는 리눅스 구조, 다케우치 사토루
