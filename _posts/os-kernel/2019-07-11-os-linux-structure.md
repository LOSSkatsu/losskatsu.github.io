---
title: "[운영체제] 리눅스 구조 정리" 
categories:
  - os-kernel
tags:
  - os
use_math: true
toc: true
toc_label: "My Table of Contents"
toc_icon: "cog"
sidebar:
  title: "AI Machine Learning"
  nav: sidebar-contents
---

# [운영체제] 리눅스 구조 정리

## 1. 컴퓨터 시스템 개요

컴퓨터의 기본 요소는 CPU와 메모리. CPU는 메모리에 있는 내용을 읽고 연산 결과를 메모리의 다른 영역에 기록한다. 

프로그램: 사용자에게 필요한 하나의 처리(기능)로 정리한 것

일반적으로 OS는 여러가지 프로그램을 프로세스 단위로 실행. OS는 여러개의 프로세스를 동시에 실행 가능. 

애플리케이션: 사용자가 직접 사용 


## 2. 사용자 모드로 구현되는 기능

프로세스는 커널의 도움이 필요할 경우 시스템 콜을 통해 커널에 처리를 요청.

시스템 콜의 종류

* 프로세스 생성, 삭제
* 메모리 확보, 해제
* 프로세스 간 통산(IPC)
* 네트워크
* 파일 시스템 다루기
* 파일 다루기(디바이스 접근)

프로세스는 보통 사용자 모드로 실행되고 있지만 커널에 처리를 요청하고자 시스템 콜을 호출하면 CPU에서는 인터럽트 이벤트 발생. 
인터럽트 이벤트가 발생하면 CPU는 사용자 모드에서 커널 모드로 변경되며 요청한 내용을 처리하기 위해 커널은 동작하기 시작함. 

strace: 프로세스가 어떤 시스템 콜을 호출했는지 확인 가능.

```bash
$ strace -o hello.log ./hello
```

sar: 프로세스가 사용자 모드와 커널 모드 중 어느쪽에서 실행되고 있는지 비율 확인

```bash
$ sar -P ALL 1 1
```
이 때, 세번째 파라미터는 1초 단위로 측정(측정 시간 단위), 네번째 파라미터는 1회 측정(측정 횟수). 
%user + %nice = 사용자모드, %system = 커널모드. 
대체로 %system 수치가 크면 시스템에 과부하가 걸려있는 등 좋지 않은 상태를 뜻함. 
<br />

시스템 콜은 C언어 같은 고급언어에서는 호출이 불가능하다. 아케텍처에 의존하는 어셈블리 코드를 사용해 호출해야함. 
이러한 문제를 해결하기 위해 OS는 내부적으로 시스템 콜을 호출하는 일만 하는 함수를 제공하는 데, 이를 wrapper라고 한다. 

ldd: 프로그램이 어떤 라이브러리를 링크하고 있는지 확인

```bash
$ ldd /bin/echo
```

## 3. 프로세스 관리

fork(): 실행한 프로세스와 함께 새로운 프로세스 1개 생성. 같은 프로그램의 처리를 여러 개의 나눠서 처리함. 

execve(): 전혀 다른 프로그램 생성 시 사용. 

엔트리포인트(entry point): 최초로 실행할 명령의 메모리 주소

리눅스의 실행파일은 ELF(Executable Linkable Format)이라는 형식 사용. 

readelf: ELF 형식의 각종 정보 확인 가능. -h옵션으로 시작 주소 획득 가능. 
-S 옵션으로 오프셋, 사이즈, 메모리맵 시작주소 확인 가능. 
결과에서 .text는 코드영역 정보, .data는 데이터 영역 정보를 의미  

```bash
$ readelf -h /bin/sleep
$ readelf -S /bin/sleep
```




참고: 실습과 그림으로 배우는 리눅스 구조, 다케우치 사토루
